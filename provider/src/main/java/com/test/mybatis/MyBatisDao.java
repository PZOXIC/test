package com.test.mybatis;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.log4j.Logger;
import org.mybatis.spring.support.SqlSessionDaoSupport;
import org.springframework.beans.factory.annotation.Autowired;


/**
 * The central class which provides basic programming model.
 * 
 * @version 1.0,2013-07-08
 */

public class MyBatisDao extends SqlSessionDaoSupport implements DAO {

	private static final Logger logger = Logger.getLogger(MyBatisDao.class);

	/**
	 * mybatis-spring 1.1.1这么写
	 */
//	@Inject
//	private SqlSessionFactory sqlSessionFactory;
	
	/**
	 * mybatis-spring 1.2.2这么写
	 */
	
	@Override
    @Autowired
    public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
        super.setSqlSessionFactory(sqlSessionFactory);
    }

	/**
	 * Executes a mapped SQL INSERT statement. Insert is a bit different from
	 * other update methods, as it provides facilities for returning the primary
	 * key of the newly inserted row (rather than the effected rows). This
	 * functionality is of course optional.
	 * <p/>
	 * The parameter object is generally used to supply the input data for the
	 * INSERT values.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @param parameterObject
	 *            The parameter object (e.g. JavaBean, Map, XML etc.).
	 * @return The primary key of the newly inserted row. This might be
	 *         automatically generated by the RDBMS, or selected from a sequence
	 *         table or other source.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public Object insert(String statement, Object parameterObject)
			throws Exception {
		try {
			return this.getSqlSession().insert(statement, parameterObject);
		} catch (Exception e) {
			logger.error(e.getMessage());
			// TODO Auto-generated catch block
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL INSERT statement. Insert is a bit different from
	 * other update methods, as it provides facilities for returning the primary
	 * key of the newly inserted row (rather than the effected rows). This
	 * functionality is of course optional.
	 * <p/>
	 * This overload assumes no parameter is needed.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @return The primary key of the newly inserted row. This might be
	 *         automatically generated by the RDBMS, or selected from a sequence
	 *         table or other source.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public Object insert(String statement) throws Exception {
		try {
			return this.getSqlSession().insert(statement);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL UPDATE statement. Update can also be used for any
	 * other update statement type, such as inserts and deletes. Update returns
	 * the number of rows effected.
	 * <p/>
	 * The parameter object is generally used to supply the input data for the
	 * UPDATE values as well as the WHERE clause parameter(s).
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @param parameterObject
	 *            The parameter object (e.g. JavaBean, Map, XML etc.).
	 * @return The number of rows effected.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public int update(String statement, Object parameterObject)
			throws Exception {
		try {
			return this.getSqlSession().update(statement, parameterObject);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL UPDATE statement. Update can also be used for any
	 * other update statement type, such as inserts and deletes. Update returns
	 * the number of rows effected.
	 * <p/>
	 * This overload assumes no parameter is needed.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @return The number of rows effected.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public int update(String statement) throws Exception {
		try {
			return this.getSqlSession().update(statement);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL DELETE statement. Delete returns the number of rows
	 * effected.
	 * <p/>
	 * The parameter object is generally used to supply the input data for the
	 * WHERE clause parameter(s) of the DELETE statement.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @param parameterObject
	 *            The parameter object (e.g. JavaBean, Map, XML etc.).
	 * @return The number of rows effected.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public int delete(String statement, Object parameterObject)
			throws Exception {
		try {
			return this.getSqlSession().delete(statement, parameterObject);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL DELETE statement. Delete returns the number of rows
	 * effected.
	 * <p/>
	 * This overload assumes no parameter is needed.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @return The number of rows effected.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public int delete(String statement) throws Exception {
		try {
			return this.getSqlSession().delete(statement);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL SELECT statement that returns data to populate a
	 * single object instance.
	 * <p/>
	 * This overload assumes no parameter is needed.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @return The single result object populated with the result set data, or
	 *         null if no result was found
	 * @throws Exception
	 *             If more than one result was found, or if any other error
	 *             occurs.
	 */
	public Object queryForObject(String statement) throws Exception {
		return this.getSqlSession().selectOne(statement);
	}

	/**
	 * Executes a mapped SQL SELECT statement that returns data to populate the
	 * supplied result object.
	 * <p/>
	 * The parameter object is generally used to supply the input data for the
	 * WHERE clause parameter(s) of the SELECT statement.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @param parameterObject
	 *            The parameter object (e.g. JavaBean, Map, XML etc.).
	 * @param resultObject
	 *            The result object instance that should be populated with
	 *            result data.
	 * @return The single result object as supplied by the resultObject
	 *         parameter, populated with the result set data, or null if no
	 *         result was found
	 * @throws Exception
	 *             If more than one result was found, or if any other error
	 *             occurs.
	 */
	public Object queryForObject(String statement, Object parameterObject)
			throws Exception {
		try {
			return (Object) this.getSqlSession().selectOne(statement,
					parameterObject);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL SELECT statement that returns data to populate a
	 * number of result objects.
	 * <p/>
	 * The parameter object is generally used to supply the input data for the
	 * WHERE clause parameter(s) of the SELECT statement.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @param parameterObject
	 *            The parameter object (e.g. JavaBean, Map, XML etc.).
	 * @return A List of result objects.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public List<?> queryForList(String statement, Object parameterObject,
			int offset, int limit) throws Exception {
		try {
			RowBounds rb = new RowBounds(offset, limit);
			return this.getSqlSession().selectList(statement, parameterObject,
					rb);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Executes a mapped SQL SELECT statement that returns data to populate a
	 * number of result objects.
	 * <p/>
	 * The parameter object is generally used to supply the input data for the
	 * WHERE clause parameter(s) of the SELECT statement.
	 * 
	 * @param id
	 *            The name of the statement to execute.
	 * @param parameterObject
	 *            The parameter object (e.g. JavaBean, Map, XML etc.).
	 * @return A List of result objects.
	 * @throws Exception
	 *             If an error occurs.
	 */
	public List<?> queryForList(String statement, Object parameterObject)
			throws Exception {
		try {
			return this.getSqlSession().selectList(statement, parameterObject);
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		}
	}

	/**
	 * Retrieves the number,types and properties of this ResultSet object's
	 * column
	 * 
	 * @param sql
	 * @return
	 */
	public List<Map<String, Object>> getMetaDataLimits(String tableName)
			throws Exception {
		Connection connection = null;
		String statement = " select * from " + tableName;
		Map<String, Object> every = null;
		List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
		try {

			connection = this.getSqlSession().getConnection();

			PreparedStatement pstatement = connection
					.prepareStatement(statement);
			ResultSet rs = pstatement.executeQuery();
			ResultSetMetaData rsMetaData = rs.getMetaData();

			int count = rsMetaData.getColumnCount();
			for (int i = 1; i <= count; i++) {
				// logger.info("ColumnName===" + rsMetaData.getColumnName(i));
				// logger.info("ColumnTypeName===" +
				// rsMetaData.getColumnTypeName(i));
				// logger.info("ColumnType===" + rsMetaData.getColumnType(i));
				// //类型
				// logger.info("Precision==" + rsMetaData.getPrecision(i)); //列宽
				// logger.info("Nullable==" + rsMetaData.isNullable(i)); //空

				every = new HashMap<String, Object>();
				every.put("ColumnName", rsMetaData.getColumnName(i));
				every.put("ColumnTypeName", rsMetaData.getColumnTypeName(i));
				every.put("ColumnType", rsMetaData.getColumnType(i));
				every.put("Length", rsMetaData.getPrecision(i));
				every.put("isNull", rsMetaData.isNullable(i));

				result.add(i - 1, every);
			}

			return result;
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new Exception(e);
		} finally {
			try {
				connection.close();
			} catch (Exception e) {
				throw new Exception(e);
			}
		}
	}
	
	/*public Object queryForObject2(final String statementName, final Object parameterObject)
			throws DataAccessException {
		return execute(new SqlMapClientCallback() {
			public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
				return executor.queryForObject(statementName, parameterObject);
			}
		});
	}*/

}
